---
title: "Genomic prediction for quantitative traits"
authors: "E. Tourrette, B. Servin, T. Flutre"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
format:
  html:
    toc: true
    toc-depth: 5
    toc-location: left
    number-sections: true
editor: visual
execute:
  freeze: auto
  cache: true
---

# Preamble

Load the dependencies:

```{r}
suppressPackageStartupMessages(library(Matrix))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(kinship2))
suppressPackageStartupMessages(library(sommer))
suppressPackageStartupMessages(library(rrBLUP))
```

# Main objective

In the goal of understanding the genetic determinism of complex traits, this session will show how to answer the question "how to replace pedigree-based kinship with SNP-based kinship?".

# Reminder of central concepts

Genetics is the study of heritable variation, and the goals of quantitative genetics are to (i) partition phenotypic variance into genetic vs. environmental components, (ii) predict genotypic values based on the resemblance between relatives, and (iii) find the underlying loci contributing to the genetic variance. In the following, the most important concepts are *briefly* summarized for traits displaying quantitative variation; see Lynch and Walsh (1998) as well as [de Los Campos (2015)](https://dx.plos.org/10.1371/journal.pgen.1005048) for more details.

## Genetic variance

Let us imagine a population of $n$ diploid individuals at Hardy-Weinberg equilibrium (HWE), phenotyped for a given trait. In the theory of quantitative genetics, if part of the phenotypic variation is of genetic origin, it means that (i) we assume the existence of $q$ **quantitative trait locus** (QTLs) with genetic effects on the trait, and (ii) the genetic variance comes from the individuals differing by their genotypes at these QTLs.

With $i \in \{1,\ldots,n\}$ to index the individuals, the phenotypic value of individual $i$ is noted $y_i$. With $j \in \{1,\ldots,q\}$ to index the QTLs, the genotype of individual $i$ at QTL $j$ corresponds to its **allele content**, noted $z_{ij}$. The genotype of individual $i$ at all QTLs is the vector $\boldsymbol{z_i}$. To simplify, all variables are centered: $E[y_i] = E[z_{ij}] = 0$. The **genetic value** of an individual is then defined as its expected phenotypic value, over all possible environments, given its genotypes at the QTLs: \begin{align}
g_i = E_{env}[y_i|\boldsymbol{z_i}]
\end{align}

In a given macro-environment, an analysis of variance is applied with the phenotypic value as response variable and the genetic value as explanatory factor: $y_i = g_i + \epsilon_i$, where $\epsilon_i$ is a residual error corresponding to micro-environmental variation. By construction, the phenotypic variance is: $\sigma_p^2 = \sigma_g^2 + \sigma^2$. Moreover, the squared correlation between $g$ and $y$, known as **broad-sense heritability**, equals: $H^2 := \sigma_g^2 / \sigma_p^2$.

The **genetic variance** for the trait in the population is informally defined as the variance of the genetic values. However, the genetic values combine two sources of information, both being unknown: the genetic effects of the QTLs as well as the genotypes of individuals at the QTLs. In the classical framework of quantitative genetics, inspired by the frequentist paradigm of statistics:

-   the QTL genetic effects are considered as "fixed parameters",

-   the individual genotypes at QTLs are considered as "random variables".

As a result, the genetic variance is the expectation, over the individual genotypes at the QTLs, of the squared deviation of the genetic values from their population mean: \begin{align}
\sigma_g^2 &:= E_z[ (g_i - E_z[g_i])^2 ] = E_z[g_i^2] - (E_z[g_i])^2 \\
&= E_z[g_i^2] - (E_z[E_{env}[y_i|\boldsymbol{z_i}]])^2 = E_z[g_i^2] - (E_{env}[y_i])^2 \; \; \leftarrow \text{(law of total expectation)}  \\
&= E_z[g_i^2]
\end{align}

Most likely, the genetic value is a *non-linear* function of QTL effects and genotypes. Moreover, under sexual reproduction (on which we focus here), a key insight is that a parent only transmits to its offsprings a single allele at each QTL, not its whole genotype. The strategy hence consists in approximating the genetic value by linearly regressing it on allele content: $g_i = \boldsymbol{z_i}^T \boldsymbol{\alpha} + \delta_i$ where $\boldsymbol{\alpha}$ is the vector of **additive genetic effects** of the QTLs (also known as *allele substitutions*) and $\delta_i$ is a residual deviation including intra-locus and inter-locus interactions (dominance and epistasis, respectively) as well as QTL-environment interactions. The **additive genetic value** is then defined as: $g_{a,i} := \boldsymbol{z_i}^T \boldsymbol{\alpha}$. Finding the best approximation, in the sense of the least squares, leads to: $\boldsymbol{\alpha} = Cov(z_i,z_i^T)^{-1} Cov(z_i,g_i)$ where $\Sigma_z := Cov(z_i,z_i^T)$ corresponds to the variance-covariance matrix of allele contents at the QTLs.

Based on the linear regression above, the **additive genetic variance** is defined as: $\sigma_a^2 := Cov(\boldsymbol{z_i}^T \boldsymbol{\alpha}) = \boldsymbol{\alpha}^T \Sigma_z \boldsymbol{\alpha}$. More specifically: \begin{align}
\sigma_a^2 = \sum_j Var(z_{ij}) \alpha_j^2 \; + \; 2 \sum_j \sum_{j' > j} Cov(z_{ij},z_{ij'}) \alpha_j \alpha_{j'}
\end{align} The additive genetic variance thus not only depends on the contribution of genetic effects and variance of allelic contents, but also on the covariance of allelic contents between QTLs, known as **linkage disequilibrium**. The **narrow-sense heritability** is defined as: $h^2 := \sigma_a^2 / \sigma_p^2$.

The **breeding value** (BV) of individual $i$ is defined as twice the expected deviation of the mean phenotype of this individual's progeny from the population mean, when mated at random to other individuals from the population: $BV_i = 2 \times E[y_{\text{offsprings of $i$}} - \mu]$, so that the breeding value of an individual quantifies its *value as a parent*. The breeding value is mostly equal to the additive genetic value, but not exactly: it is not only half the additive genetic effects that are transmitted from parent to offspring, but also a small part of epistatic interactions.

## Genetic relationships

Two individuals are considered genetically identical for a given trait, that is, they have the same genetic value, if they have the same genotypes at the QTLs for that trait. In other words, what counts for two individuals to be genetically identical is if they have alleles that are **identical by states** (IBS) at causal genes. But these genes are usually unknown. Still, related individuals are more likely to be genetically similar because they are more likely to have inherited the same alleles at the QTLs.

To quantify this, the **coancestry coefficient** between individuals $i$ and $i'$, noted $\phi_{a,ii'}$ and also known as the *kinship* coefficient, is the probability that an allele taken at random from individual $i$ is **identical by descent** (IBD) with an allele randomly drawn from individual $j$. For both alleles to be IBD means that they come from the exact same allele in an ancestor some generations ago.

It can then be shown that: $Cov(g_{a,i},g_{a,i'}) = 2 \, \phi_{a,ii'} \, \sigma_a^2$. The **additive genetic relationship** between both individuals is defined as twice the coancestry coefficient: $A_{ii'} := 2 \, \phi_{a,ii'}$. When the causal genes are unknown (most of the cases), the resemblance between relatives can thus be used to estimate the additive genetic variance.

Concretely, this requires to phenotype $n$ individuals from multiple generations for which we know their **pedigree**. Efficient algorithms exist to compute coancestry coefficients, and all pairwise additive genetic relationships are gathered into the so-called numerator relationship matrix noted $A$.

Relationships are always interpreted with respect to a reference population. With a pedigree, the default reference population is made of the the founders, assumed unrelated, and it is called the **base population**.

## Linear mixed model

Estimating variance components requires a **linear mixed model** (LMM) whose generic form is: $\boldsymbol{y} = X \boldsymbol{\beta} + Z \boldsymbol{u} + \boldsymbol{\epsilon}$, where $\boldsymbol{y}$ is the $n$-vector of phenotypes, $X$ is the $n \times p$ design matrix for the explanatory factors whose effects, $\boldsymbol{\beta}$, are modeled as "fixed", $Z$ is the $n \times q$ design matrix for the explanatory factors whose effects, $\boldsymbol{u}$, are modeled as "random", and $\boldsymbol{\epsilon}$ are residual errors. Moreover, $E[\boldsymbol{u}]=0$, $Var(\boldsymbol{u})=G(\gamma)$, $E[\boldsymbol{\epsilon}]=0$, $Var(\boldsymbol{\epsilon})=R(\phi)$, and $Cov(\boldsymbol{u},\boldsymbol{\epsilon})=0$.
Caution, the $G$ matrix above does NOT correspond to the genetic variance-covariance matrix between multiple traits as used in evolutionary quantitative genetics.

In classical quantitative genetics, the specific type of LMM used to estimate the additive genetic variance is called a *variance-component* model (vc-LMM): $\boldsymbol{y} = X \boldsymbol{\beta} + Z \boldsymbol{g}_a + \boldsymbol{\epsilon}$. The additive genetic values, $\boldsymbol{g}_a$, are modeled as random, and their variance-covariance matrix is $G(\gamma) := \sigma_u^2 \, A$, so that $\gamma := \sigma_u^2$. Moreover, the variance-covariance matrix of the residual errors usually is $R(\phi) := \sigma^2 \, \text{Id}_n$ so that $\phi := \sigma^2$. In practice, the variance components $\sigma_u^2$ and $\sigma^2$ are often estimated by **restricted maximum likelihood** (ReML).

More generally, the genetic variance component, $\sigma_u^2$, corresponds to the genetic variance of the reference population used to compute the genetic relationships. In the case of pedigree-based relationships, $\sigma_u^2$ hence is the variance of the founder's additive genetic values.

## BLUP

The **mixed model equations** (MMEs) are used to obtain formulas for the best linear unbiased estimator (BLUE) of the fixed effects, and the **best linear unbiased predictor** (BLUP) of the random effects: $BLUP(\boldsymbol{u}) = G Z^T V^{-1} (\boldsymbol{y} - X \boldsymbol{\beta})$ where $V := Var(\boldsymbol{y}) = Z G Z^T + R$. When the estimates of the variance components are used, the so-called empirical BLUPs (eBLUPs) can be computed.

The additive genetic values of unphenotyped individuals can be predicted as long as their additive genetic relationships with phenotyped individuals, $G_{trn,tst}$, are known.
Indeed, following [Henderson (1977)](https://linkinghub.elsevier.com/retrieve/pii/S0022030277839350) and [Lopez-Cruz and De Los Campos (2021)](https://academic.oup.com/genetics/article/doi/10.1093/genetics/iyab030/6179494), the data set can be partitioned into a training (trn) and testing (tst) set.
The objective is to predict the genetic values of the individuals in the testing set ($\boldsymbol{u}_{tst}$) using the phenotype data available from the training set ($\boldsymbol{y}_{trn}$).
The best linear predictor is: \begin{align}
\hat{\boldsymbol{u}}_{tst} = G^T_{trn,tst} (G_{trn} + \hat{\lambda} I)^{-1} \boldsymbol{y}_{trn}
\end{align}
where $\hat{\lambda} := \hat{\sigma}^2 / \hat{\sigma}_u^2$.

## Mendelian deviations

This above procedure is very useful but its accuracy can be substantially increased. Indeed, unphenotyped individuals with the same genetic relationships get the same genetic value; as in the case of full siblings. This is because the genetic relationships estimated from the pedigree are *expected* relationships assuming an infinite number of loci. However, a parent passes a *sampled* half of its alleles to its offsprings, that is, a gamete carries a *random assortment* (RA) of parental alleles, also called **Mendelian deviations**. The breeding value of offspring $o$ resulting from the cross of individuals $i$ and $i'$ can hence be modeled as: $BV_o = [(1/2) BV_i + RA_i] + [(1/2) BV_{i'} + RA_{i'}]$.

Importantly, Mendelian deviations are what breeding relies on in order to obtain a positive response to selection. It is thus important to take these deviations into account, which is made possible by genotyping individuals at $L$ markers. However, the usage of genomic markers in this purpose raises various questions, that will be explored below with simulations.

<!-- ==================================================================== -->

# Simulate data

## Simulation scenarios

In all scenarios, first, a neutral coalescent is used as a burn-in phase to simulate a population (with `msprime`), then 10 generations are done via forward-in-time simulations (with `simuPOP`). The population size is constant, with 100 individuals at each generation.

For each scenario, two correlated traits are simulated. Both traits are in complete pleiotropy, and the effect of their QTLs are correlated. The first trait has a medium heritability whereas the second has a high heritability.
In scenarios with selection, only the first trait is directly under selection, the second being indirectly selected.

## Simulation outputs

Each simulation provides different types of data, similar to what is usually available from experiments, that we will use in the subsequent analysis:

-   the pedigree information (`pedigree.txt`): individual ID, father and mother ID (0 if unknown), the sex, the generation and the phenotypic and true genetic values (unavailable in practice, but can be estimated); depending on the population studied (e.g., breeding or natural population), it may not be possible to get the pedigree;

-   the genotypes (`genotype.txt`): for each individual (row), returns the genotype (0, 1 or 2) of each SNP (column); the individual ID refers to the ones found in the pedigree while the SNP ID refers to the ones found in the SNP information file;

-   the SNP information (`SNP_INFO.txt`): SNP ID, chromosome, genetic position, reference and alternative alleles; we also added the true SNP effects on the traits (unavailable in practice, but can be estimated)

-   the lineage information (`IBD.txt`): same format as the genotype file, except that it returns the origin of each SNP (the individuals being diploids, there is one row for each homologous chromosome); the origin refers to the ID of the individual from the first generation from which the allele is from, the sign indicating from which chromosome it is from; this give an information about the IBD (identity by descent, i.e., if two alleles of a SNP are not only identical but are also from the same individual initially), and so, can help to calculate the tree relationship matrix between two individuals; this information is unavailable in practice but can estimated.

For more detailed information about the simulations, see the file `simulations/readme.md`.

## Simulation 1

All SNPs have an effect, i.e., they are QTLs; with linkage; without selection

```{bash, eval=FALSE}
conda activate qlife_simu
cd simulations
python src/main.py -savedFolder "genpred_simul1" -optim 0 -varW 10 -G 10 -N 100 -Npop 10000 -h2 0.5,0.9 -nTrait 2 -nChr 5 -Lchr 1000 -LG 100 -mu 1e-5 -proportion0 1.0 -varEffect0 1.0 -nQTL 0 -varEffect 0.0 -corTrait 0.9 -signCor 'neg' >> out_genpred1 &
```

## Simulation 2

All SNPs have an effect, i.e., they are QTLs; with linkage; with selection

```{bash, eval=FALSE}
conda activate qlife_simu
cd simulations
python src/main.py -savedFolder "genpred_simul2" -optim 5 -varW 10 -G 10 -N 100 -Npop 10000 -h2 0.5,0.9 -nTrait 2 -nChr 5 -Lchr 1000 -LG 100 -mu 1e-5 -proportion0 1.0 -varEffect0 1.0 -nQTL 0 -varEffect 0.0 -corTrait 0.9 -signCor 'neg' >> out_genpred2 &
```

## Simulation 3

All SNPs have an effect, i.e., they are QTLs, but some have a bigger effect than others; with linkage; with selection

```{bash, eval=FALSE}
conda activate qlife_simu
cd simulations
python src/main.py -savedFolder "genpred_simul3" -optim 5 -varW 10 -G 10 -N 100 -Npop 10000 -h2 0.5,0.9 -nTrait 2 -nChr 5 -Lchr 2000 -LG 100 -mu 1e-5 -proportion0 1.0 -varEffect0 0.01 -nQTL 100 -varEffect 100.0 -corTrait 0.9 -signCor 'neg' >> out_genpred3 &
```

<!-- ==================================================================== -->

# Load all the data

Change this to load the data from different simulations:
```{r}
simulDir <- "genpred_simul2"
```

## Pedigree

```{r}
inF <- file.path("simulations", simulDir, "pedigree.txt")
stopifnot(file.exists(inF))
pedDat <- read.table(inF, header=TRUE, sep=" ", stringsAsFactors=FALSE)
str(pedDat)
```

Based on the generations, subset the individuals in four sets: the first for generation 0, the second for all generations except 0, the third for the last generation, and the fourth for all generation except 0 and the last.

```{r}
stopifnot(length(unique(pedDat$ind_id)) == nrow(pedDat))
pedDat$ind_id <- as.character(pedDat$ind_id)
rownames(pedDat) <- pedDat$ind_id
table(pedDat$generation)
inds_gen0 <- pedDat$ind_id[pedDat$generation == "0"]
inds_not0 <- pedDat$ind_id[pedDat$generation != "0"]
inds_last <- pedDat$ind_id[pedDat$generation == max(pedDat$generation)]
inds_notlast <- pedDat$ind_id[pedDat$generation != max(pedDat$generation)]
inds_mid <- pedDat$ind_id[! pedDat$ind_id %in% inds_gen0 &
                            ! pedDat$ind_id %in% inds_last]
pedDat$generation <- factor(as.character(pedDat$generation),
                            levels=as.character(sort(unique(pedDat$generation))),
                            ordered=TRUE)
```

## True breeding values and phenotypes

The true breeding values and the phenotypic values are also provided in the file containing the pedigree.

Keep the true genetic variances:

```{r}
#| code-fold: true
(truth <- list("trait1"=list(varBV_all=var(pedDat[, "bv1"]),
                             varBV_gen0=var(pedDat[inds_gen0, "bv1"]),
                             varBV_not0=var(pedDat[inds_not0, "bv1"])),
               "trait2"=list(varBV_all=var(pedDat[, "bv2"]),
                             varBV_gen0=var(pedDat[inds_gen0, "bv2"]),
                             varBV_not0=var(pedDat[inds_not0, "bv2"])),
               "trait1-trait2"=list(corBV_gen0=cor(pedDat[inds_gen0, "bv1"],
                                                   pedDat[inds_gen0, "bv2"]))))
```

Visualize the phenotypic and breeding values:

```{r, fig.width=10}
#| code-fold: true
for(traitNum in 1:2){
  p <- ggplot(pedDat) +
    aes(x=.data[[paste0("pheno",traitNum)]]) +
    geom_histogram(bins=30, color="white") +
    labs(title=paste0("Trait ", traitNum),
         subtitle=simulDir,
         x="phenotypic value") +
    theme_bw()
  print(p)
  p <- ggplot(pedDat) +
    aes(x=generation, color=generation,
        y=.data[[paste0("pheno",traitNum)]]) +
    geom_violin(trim=FALSE) +
    geom_boxplot(width=0.2) +
    labs(title=paste0("Trait ", traitNum),
         subtitle=simulDir,
         y="phenotypic value") +
    theme_bw()
  print(p)
  p <- ggplot(pedDat) +
    aes(x=.data[[paste0("bv",traitNum)]]) +
    geom_histogram(bins=30, color="white") +
    labs(title=paste0("Trait ", traitNum),
         subtitle=simulDir,
         x="breeding value") +
    theme_bw()
  print(p)
  p <- ggplot(pedDat) +
    aes(x=generation, color=generation,
        y=.data[[paste0("bv",traitNum)]]) +
    geom_violin(trim=FALSE) +
    geom_boxplot(width=0.2) +
    labs(title=paste0("Trait ", traitNum),
         subtitle=simulDir,
         y="breeding value") +
    theme_bw()
  print(p)
}

for(traitNum in 1:2){
  p <- ggplot(pedDat) +
    aes(x=.data[[paste0("bv",traitNum)]],
        y=.data[[paste0("pheno",traitNum)]],
        color=generation) +
    geom_hline(yintercept=0, linetype="dotted") +
    geom_vline(xintercept=0, linetype="dotted") +
    geom_point() +
    labs(title=paste0("Trait ", traitNum),
         subtitle=simulDir,
         x="true breeding value", y="phenotypic value") +
    theme_bw()
  print(p)
}
```

## SNP genotypes

```{r}
inF <- file.path("simulations", simulDir, "genotype.txt")
stopifnot(file.exists(inF))
genos <- read.table(inF, header=TRUE, sep="\t", stringsAsFactors=FALSE,
                    row.names=1, check.names=FALSE)
genos <- as.matrix(genos)
stopifnot(all(genos >= 0 & genos <= 2))
str(genos)
genos[1:3, 1:10]
```

## SNP effects

```{r}
inF <- file.path("simulations", simulDir, "SNP_INFO.txt")
stopifnot(file.exists(inF))
snpInfos <- read.table(inF, header=TRUE, sep="\t", colClasses=c("snp_id"="character"))
str(snpInfos)
head(snpInfos)
length(unique(snpInfos$snp_id))
table(snpInfos$chr_id)
(truth$trait1$varBeta <- var(snpInfos$beta_trait_1))
(truth$trait2$varBeta <- var(snpInfos$beta_trait_2))
```

## Lineages

```{r}
inF <- file.path("simulations", simulDir, "IBD.txt")
stopifnot(file.exists(inF))
IBDs <- read.table(inF, header=TRUE, sep="\t", stringsAsFactors=FALSE, check.names=FALSE)
str(IBDs, list.len=6)
IBDs[1:3, 1:8]
```

<!-- ==================================================================== -->

# Estimate genetic relationships

## True IBD relationships

### Function

```{r}
##' @param IBDs data.frame with two rows per individual (one per haplotype), the first column contains the individual IDs, the second column indicates the haplotype, and all the other columns correspond to SNPs
getGRMibd <- function(IBDs){
  stopifnot(is.data.frame(IBDs),
            all(c("hom1","hom2") == sort(unique(IBDs[,2]))))

  id <- IBDs[,1]
  chrh <- IBDs[,2]
  x <- IBDs[,-c(1:2)]
  x <- t(x) # transpose to have SNPs in rows

  ## extract the number of haplotypes, sites and individuals
  nHap <- ncol(x)
  nSit <- nrow(x)
  nInd <- nHap/2

  ## calculate the number of sites, between two haplotypes, that come from the same individual and chromosome
  G <- matrix(data = numeric(), nrow = nHap, ncol = nHap)
  for(h1 in 1:nHap) {
    tmp <- x[,h1]
    for(h2 in 1:h1) {
      G[h1,h2] <- G[h2,h1] <- sum(tmp == x[,h2])
    }
  }

  ## calculate the relationship matrix between two individuals
  ## via the number of sites that are in common between two individuals (four haplotypes)
  G2 <- matrix(numeric(), nrow = nInd, ncol = nInd)
  for(i in seq(1, 2*nInd, by = 2)) {
    for(j in seq(i, 2*nInd, by = 2)) {
      tmp <- G[i:(i+1), j:(j+1)]
      G2[(i+1)/2, (j+1)/2] <- G2[(j+1)/2, (i+1)/2] <- sum(tmp)
    }
  }

  GRM_IBD <- G2 / (2*nSit)
  rownames(GRM_IBD) <- colnames(GRM_IBD) <- unique(id)

  return(GRM_IBD)
}
```

### Usage

```{r}
system.time(GRM_IBD <- getGRMibd(IBDs))

GRM_IBD_gen0 <- GRM_IBD[inds_gen0, inds_gen0]
GRM_IBD_not0 <- GRM_IBD[inds_not0, inds_not0]
GRM_IBD_mid <- GRM_IBD[inds_mid, inds_mid]
```

### Plots

```{r, fig.width=10}
#| code-fold: true
image(as(GRM_IBD, "Matrix"), main=paste0("GRM_IBD (all generations)\n", simulDir))
hist(diag(GRM_IBD), main=paste0("diag of GRM_IBD (all generations)\n", simulDir))
hist(GRM_IBD[upper.tri(GRM_IBD)], main=paste0("offdiag of GRM_IBD (all generations)\n", simulDir))

image(as(GRM_IBD_gen0, "Matrix"), main=paste0("GRM_IBD (generation 0)\n", simulDir))
summary(diag(GRM_IBD_gen0))
summary(GRM_IBD_gen0[upper.tri(GRM_IBD_gen0)])

if(FALSE){
  image(as(GRM_IBD_not0, "Matrix"), main=paste0("GRM_IBD (except generation 0)\n", simulDir))
  hist(diag(GRM_IBD_not0))
  hist(GRM_IBD_not0[upper.tri(GRM_IBD_not0)])
  
  image(as(GRM_IBD_mid, "Matrix"), main=paste0("GRM_IBD (except first and last generations)\n", simulDir))
  hist(diag(GRM_IBD_mid))
  hist(GRM_IBD_mid[upper.tri(GRM_IBD_mid)])
}
```

## Expected relationships from the pedigree

### Reformat

Make a specific object with the `kinship2` package:

```{r}
ped <- pedigree(id=as.integer(pedDat$ind_id),
                dadid=as.integer(pedDat$father_id),
                momid=as.integer(pedDat$mother_id),
                sex=pedDat$sex)
ped
```

```{r, fig.width=10, eval=FALSE}
#| code-fold: true
plot(ped)
```

### Compute kinship

Estimate the coancestry coefficient, the `kinship` function using a recursive algorithm described in Lange's book "Mathematical and statistical methods for genetics analysis" (ch.5 on genetic identity coefficients):

```{r}
A <- 2 * kinship(ped)
dim(A)
```

### Plots

```{r, fig.width=10}
image(as(A, "Matrix"), main=paste0("A (all generations)\n", simulDir))
hist(diag(A), main=paste0("diag of A (all generations)\n", simulDir))
hist(A[upper.tri(A)], main=paste0("offdiag of A (all generations)\n", simulDir))

A_gen0 <- A[inds_gen0, inds_gen0]
image(as(A_gen0, "Matrix"), main=paste0("A (generation 0)\n", simulDir))
summary(diag(A_gen0))
summary(A_gen0[upper.tri(A_gen0)])
```

## Realized relationships from markers

Let the markers be biallelic SNPs indexed by $l \in \{1,\ldots,L\}$, $f_l$ being the allele frequency of marker $l$, and $M_{il}$ being the number of reference alleles for individual $i$ at marker $l$ ($\in \{0,1,2\}$), so that $M$ is the $n \times L$ matrix of SNP genotypes. Several estimators of additive genetic relationships exist, each providing a **genomic relationship matrix** (GRM).

### Assuming HWE and LE with Van Raden

[Van Raden (2008)](http://dx.doi.org/10.3168/jds.2007-0980) proposed two estimators relying on the molecular covariance and the allele frequency at each locus. The allele frequencies, when unknown, are replaced by their sample average, $\hat{f}_l$. See below for a discussion about the reference population.

See also [Toro et al (2011)](http://www.gsejournal.org/content/43/1/27).

#### First estimator (VR1)

The estimator of molecular covariance is computed for each locus, summed over all locus, and then standardized by the total molecular variance: \begin{align}
\hat{A}_{ii'}^{(VR1)} = \frac{1}{L} \frac{\sum_{l=1}^L (M_{il} - 2 \hat{f}_l)(M_{i'l} - 2 \hat{f}_l)}{2 \sum_{l=1}^L \hat{f}_l (1 - \hat{f}_l)}
\end{align}

Following [Schreck et al (2019)](https://academic.oup.com/genetics/article/213/2/379/5930631), in matrix form, let $P := \text{Id}_n - \boldsymbol{1}_n \boldsymbol{1}_n^T / n$ be the $n \times n$ matrix used for column-wise mean-centering, and $c_{VR1} := 2 \sum_l \hat{f}_l (1 - \hat{f}_l)$, so that $GRM_{VR1} := P M M^T P / c_{VR1}$.

```{r}
##' @param mat n x p numeric matrix, with individuals in rows and SNPs in columns; if all values are positive, the columns will be centered using the allele frequencies in `AFs`
##' @param AFs p-vector of allele frequencies; if missing, the sample average from the SNP genotypes in `mat` will be used
estimVanRanden1 <- function(mat, AFs=NULL){
  if(all(mat >= 0)){ # need column-wise mean-centering
    M <- mat
    if(is.null(AFs)){
      AFs <- colMeans(mat) / 2
    } else
      stopifnot(length(AFs) == ncol(mat))
    tmp <- matrix(rep(1, nrow(M))) %*% (2 * AFs)
    Z <- M - tmp

  } else{ # columns assumed already centered
    stopifnot(sapply(colMeans(mat), all.equal, 0.0))
    Z <- mat
  }

  tcrossprod(Z, Z) / (2 * sum(AFs * (1 - AFs)))
}
```

```{r, echo=FALSE}
#| code-fold: true
## To test the code:
if(FALSE){
  ## run without centering
  tmp <- estimVanRanden1(genos, AFs_VR1)
  stopifnot(all.equal(tmp, GRM_VR1)) # GRM_VR1 is obtained below

  ## run without centering and without providing AFs
  tmp <- estimVanRanden1(genos)
  stopifnot(all.equal(tmp, GRM_VR1))

  ## matrix formulas as in Schreck et al (2019)
  n <- nrow(genos)
  P <- diag(1, n, n) - matrix(1, n, n) / n
  c <- sum(colMeans(genos) * (1 - colMeans(genos) / 2))
  tmp <- P %*% tcrossprod(genos) %*% P / c
  stopifnot(all.equal(tmp, GRM_VR1, check.attributes=FALSE))
}
```

##### All generations

```{r, fig.width=10}
AFs_VR1 <- colMeans(genos) / 2
hist(AFs_VR1)

tmp <- matrix(rep(1, nrow(genos))) %*% (2 * AFs_VR1)
Z_VR1 <- genos - tmp
GRM_VR1 <- estimVanRanden1(Z_VR1, AFs_VR1)

image(as(GRM_VR1, "Matrix"), main=paste0("GRM_VR1 (all generations)\n", simulDir))
hist(diag(GRM_VR1), main=paste0("diag of GRM_VR1 (all generations)\n", simulDir))
hist(GRM_VR1[upper.tri(GRM_VR1)], main=paste0("offdiag of GRM_VR1 (all generations)\n", simulDir))
```

##### Generation 0

```{r}
AFs_gen0 <- colMeans(genos[inds_gen0,]) / 2
hist(AFs_gen0)

tmp <- matrix(rep(1, nrow(genos[inds_gen0,]))) %*% (2 * AFs_gen0)
Z_VR1_gen0 <- genos[inds_gen0,] - tmp
GRM_VR1_gen0 <- estimVanRanden1(Z_VR1_gen0, AFs_gen0)

image(as(GRM_VR1_gen0, "Matrix"), main=paste0("GRM_VR1 (generation 0)\n", simulDir))
hist(diag(GRM_VR1_gen0), main=paste0("diag of GRM_VR1 (generation 0)\n", simulDir))
hist(GRM_VR1_gen0[upper.tri(GRM_VR1_gen0)], main=paste0("offdiag of GRM_VR1 ( generation 0)\n", simulDir))
```

#### Second estimator (VR2)

The estimator of molecular covariance is computed for each locus, standardized, and then summed over all locus: \begin{align}
\hat{A}_{ii'}^{(VR2)} = \frac{1}{L} \sum_{l=1}^L \frac{(M_{il} - 2 f_l)(M_{i'l} - 2 f_l)}{2 f_l (1 - f_l)}
\end{align}

Although this estimator and similar ones are recommended by several authors, such as [Astle and Balding (2009)](http://dx.doi.org/10.1214/09-sts307) and [Yang et al (2010)](http://dx.doi.org/10.1038/ng.608), [Toro et al (2011)](http://www.gsejournal.org/content/43/1/27) advised against their use "because it does not agree well with genealogical coancestries, the distribution of coancestries has more variance, and it is unstable for minor allelic frequencies close to 0 and undefined for monomorphic loci".

### Departure from HWE with NOIA

Genomic relationship matrices for genetic values (additive, dominant, epistatic) can be defined in such a way as the genetic variance is partitioned into independent variance components with no covariance between them.
As a result, the estimation of one type of genetic (i.e., additive) effects will not be affected by the presence or absence of another type of genetic effects in the model (i.e., epistasis).

See the NOIA estimator:

-   Vitezica ZG, Legarra A, Toro MA, Varona L. 2017. Orthogonal Estimates of Variances for Additive, Dominance, and Epistatic Effects in Populations. Genetics. 206(3):1297--1307. doi:10.1534/genetics.116.199406.

### Handling LD with LDAK

When SNP genotypes are in linkage disequilibrium, the effect of a causal gene (QTL) ends up being allocated among its tagging SNPs, i.e., non-causal SNPs in LD with the QTL.
Speed, Balding and co-workers hence proposed to estimate genomic relatedness with a weight for each SNP, as implemented in the [LDAK software](http://ldak.org).
The sum of weights for a set of SNPs decreases as the LD amongst the SNPs increases, so that SNPs in low-LD regions contribute more to SNP heritability than those in high-LD regions.

-   Speed D, Hemani G, Johnson M, Balding D. 2012. Improved heritability estimation from genome-wide SNPs. American journal of human genetics. 91(6):1011--1021. doi:10.1016/j.ajhg.2012.10.010.

-   the UCLEB Consortium, Speed D, Cai N, Johnson MR, Nejentsev S, Balding DJ. 2017. Reevaluation of SNP heritability in complex human traits. Nat Genet. 49(7):986–992. doi:10.1038/ng.3865.

-   Speed D, Kaphle A, Balding DJ. 2022. SNP‐based heritability and selection analyses: Improved models and new results. BioEssays. 44(5):2100170. doi:10.1002/bies.202100170.

#### Run

```{bash, eval=FALSE}
## go to the folder where the results of the simulations are saved
conda activate qlife_simu
simulDir="genpred_simul2"
cd simulations/${simulDir}
mkdir -p ldak; cd ldak

## generate the .fam file from the pedigree output
## .fam: one row per ind; 6 columns (id, fam id, mom id, dad id, sex, phenotype)
awk 'BEGIN {OFS="\t"} NR>1 {print $1, "1", $3, $2, $4, $7}' ../pedigree.txt > simu.fam

## generate the .bim file from the SNP_INFO output
## .bim: one row per snp; 6 columns (chr, name, genetic distance, physical distance, A1 allele, A2 allele)
LC_NUMERIC=C awk -F'\t' 'NR==2 {divisor = $3} NR > 1 {print $2, $1, $3, $3/divisor, $4, $5}' OFS='\t' ../SNP_INFO.txt > simu.bim

## generate the .bed file from the genotypes
## first need to generate a file with the following information: SNP genotypes (0, 1, 2, NA) for the A1 allele (row = snp, column = ind)
## and then convert it to .deb using ldak
awk 'NR > 1 { $1=""; print substr($0,2) }' ../genotype.txt | tr -s ' ' '\t' | \
awk '
BEGIN { 
    FS = OFS = "\t" 
}
{
    for (i = 1; i <= NF; i++) {
        a[i] = a[i] $i "\t"
    }
}
END {
    for (i = 1; i in a; i++) {
        print substr(a[i], 1, length(a[i]) - 1)
    }
}
' > simu.txt

ldak6 --make-bed simu2 --gen simu.txt --bim simu.bim --fam simu.fam --gen-skip 0 --gen-headers 0 --gen-probs 1 --threshold 1

## calculate the weights
ldak6 --cut-weights simu_freq --bfile simu2
ldak6 --calc-weights-all simu_freq --bfile simu2 

## calculate the GRM
ldak6 --calc-kins-direct LDAKgmat_freq --bfile simu2 --weights simu_freq/weights.short --power -.25 --kinship-raw YES
```

#### Load

```{r, eval=TRUE}
inF <- file.path("simulations", simulDir, "ldak", "LDAKgmat_freq.grm.raw")
stopifnot(file.exists(inF))
GRM_ldak <- read.table(inF)
GRM_ldak <- as.matrix(GRM_ldak)
dimnames(GRM_ldak) <- list(as.character(pedDat$ind_id),
                           as.character(pedDat$ind_id))
str(GRM_ldak)

GRM_ldak_gen0 <- GRM_ldak[inds_gen0, inds_gen0]
GRM_ldak_not0 <- GRM_ldak[inds_not0, inds_not0]
GRM_ldak_mid <- GRM_ldak[inds_mid, inds_mid]
```

#### Plot

```{r}
image(as(GRM_ldak, "Matrix"), main=paste0("GRM_LDAK (all generations)\n", simulDir))
hist(diag(GRM_ldak), main=paste0("diag of GRM_LDAK (all generations)\n", simulDir))
hist(GRM_ldak[upper.tri(GRM_ldak)], main=paste0("offdiag of GRM_LDAK (all generations)\n", simulDir))

image(as(GRM_ldak_gen0, "Matrix"), main=paste0("GRM_LDAK (generation 0)\n", simulDir))
hist(diag(GRM_ldak_gen0), main=paste0("diag of GRM_LDAK (generation 0)\n", simulDir))
hist(GRM_ldak_gen0[upper.tri(GRM_ldak_gen0)], main=paste0("offdiag of GRM_LDAK (generation 0)\n", simulDir))
```

## Compare genetic relationship matrices

### Function

```{r}
##' @param mat matrix to transform
##' @param outColNs names of the columns in the output
##' @param stringsAsFactors if TRUE, character vectors will be converted to factors
##' Inspired from https://stackoverflow.com/a/41745373/597069
matWide2Long <- function(mat, outColNs=c("row","col","val")){
  stopifnot(length(outColNs) == 3)
  ind <- which(upper.tri(mat, diag=TRUE), arr.ind=TRUE)
  nn <- dimnames(mat)
  out <- data.frame(row = nn[[1]][ind[, 1]],
                    col = nn[[2]][ind[, 2]],
                    val  = mat[ind],
                    stringsAsFactors=FALSE)
  colnames(out) <- outColNs
  rownames(out) <- NULL
  return(out)
}
```

### Reformat

```{r}
genRels <- matWide2Long(GRM_IBD, c("ind_i","ind_j","IBD"))
genRels <- data.frame(genRels[,1:2],
                      diag=FALSE,
                      gen0=FALSE, not0=FALSE,
                      IBD=genRels$IBD)
genRels$diag[genRels$ind_i == genRels$ind_j] <- TRUE
genRels$gen0[genRels$ind_i %in% inds_gen0 & genRels$ind_j %in% inds_gen0] <- TRUE
genRels$not0[genRels$ind_i %in% inds_not0 & genRels$ind_j %in% inds_not0] <- TRUE
genRels$A <- matWide2Long(A, c("ind_i","ind_j","A"))$A
genRels$VR1 <- matWide2Long(GRM_VR1, c("ind_i","ind_j","VR1"))$VR1
genRels$LDAK <- matWide2Long(GRM_ldak, c("ind_i","ind_j","LDAK"))$LDAK
str(genRels)
```

### Plot A vs IBD

```{r}
ggplot(genRels) +
  aes(x=A, y=IBD) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: all generations",
       subtitle=simulDir,
       x="A", y="IBD") +
  theme_bw()

ggplot(genRels[genRels$not0,]) +
  aes(x=A, y=IBD) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: all generations except 0",
       subtitle=simulDir,
       x="A", y="IBD") +
  theme_bw()

(tmp <- summary(abs(genRels$A[genRels$not0] - genRels$IBD[genRels$not0])))
maxDiff_A_IBD <- tmp["Max."]
ggplot(genRels[genRels$not0,]) +
  aes(x=abs(A - IBD)) +
  geom_histogram(bins=30, color="white") +
  geom_vline(xintercept=tmp["Median"], color="red", linewidth=1) +
  coord_cartesian(xlim=c(0, maxDiff_A_IBD)) +
  labs(title="Comparison of genetic relationship matrices: all generations except 0",
       subtitle=simulDir,
       x="| A - IBD |") +
  theme_bw()
```

### Plot VR1 vs A and vs IBD

```{r}
ggplot(genRels) +
  aes(x=VR1, y=A) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: all generations",
       subtitle=simulDir) +
  theme_bw()

ggplot(genRels[genRels$gen0,]) +
  aes(x=VR1, y=IBD) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: generation 0",
       subtitle=simulDir) +
  theme_bw()

ggplot(genRels[genRels$not0,]) +
  aes(x=VR1, y=IBD) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: all generations except 0",
       subtitle=simulDir) +
  theme_bw()

(tmp <- summary(abs(genRels$VR1[genRels$not0] - genRels$IBD[genRels$not0])))
ggplot(genRels[genRels$not0,]) +
  aes(x=abs(VR1 - IBD)) +
  geom_histogram(bins=30, color="white") +
  geom_vline(xintercept=tmp["Median"], color="red", linewidth=1) +
  coord_cartesian(xlim=c(0, maxDiff_A_IBD)) +
  labs(title="Comparison of genetic relationship matrices: all generations except 0",
       subtitle=simulDir,
       x="| VR1 - IBD |") +
  theme_bw()
```

### Plot LDAK vs VR1 and vs IBD

```{r}
ggplot(genRels) +
  aes(x=VR1, y=LDAK) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: all generations",
       subtitle=simulDir) +
  theme_bw()

ggplot(genRels[genRels$gen0,]) +
  aes(x=VR1, y=LDAK) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: generation 0",
       subtitle=simulDir) +
  theme_bw()

ggplot(genRels[genRels$not0,]) +
  aes(x=VR1, y=LDAK) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_hex(bins=50) + 
  labs(title="Comparison of genetic relationship matrices: all generations except 0",
       subtitle=simulDir) +
  theme_bw()

(tmp <- summary(abs(genRels$LDAK[genRels$not0] - genRels$IBD[genRels$not0])))
ggplot(genRels[genRels$not0,]) +
  aes(x=abs(LDAK - IBD)) +
  geom_histogram(bins=30, color="white") +
  geom_vline(xintercept=tmp["Median"], color="red", linewidth=1) +
  coord_cartesian(xlim=c(0, maxDiff_A_IBD)) +
  labs(title="Comparison of genetic relationship matrices: all generations except 0",
       subtitle=simulDir,
       x="| LDAK - IBD |") +
  theme_bw()
```

<!-- ==================================================================== -->

# Univariate statistical analysis per trait

## Estimate variance components

### Models

#### GBLUP

The **GBLUP** model is the following vc-LMM:

```{=tex}
\begin{align}
y = \boldsymbol{\text{1}}_n \mu + \boldsymbol{u}_G + \boldsymbol{\epsilon}_G
\end{align}
```
-   $\boldsymbol{u}_G \sim \mathcal{N}(\boldsymbol{0}, \sigma_{u,G}^2 \, GRM)$

    -   $GRM$: $n \times n$ genomic relationship matrix

    -   $\boldsymbol{u}_G$: $n$-vector of genomic values modeled as random

    -   $\sigma_{u,G}^2$: genetic variance component

-   $\boldsymbol{\epsilon}_G \sim \mathcal{N}(\boldsymbol{0}, \sigma_G^2 \, \text{Id})$.

#### Comparison of genetic variance components with different reference populations

As reminded above, the reference population for pedigree relationships is non-ambiguous: it is the base population made of founders. However, the reference population is not so clear in the case of genomic estimators. When fitting a vc-LMM with either $A$ or $GRM_{VR1}$, the estimates of the genetic variance component usually are different. Leaving their uncertainty aside, does the difference only come from the fact that genomic relationships are more accurate? Notice that all pedigree relationships are positive whereas genomic relationships can be negative. The difference between estimates also come from the fact that both relationships are not on the same scale because they have different reference populations.

As explained in [Legarra (2016)](http://dx.doi.org/10.1016/j.tpb.2015.08.005), let $\boldsymbol{u}$ be the vector of genetic values of individuals *in the reference population*, assuming $E[\boldsymbol{u}] = 0$ and $Var(\boldsymbol{u}) = \sigma_u^2 K$. The genetic variance defined as: $S_u^2 := \frac{1}{n} \sum_i (u_i - \bar{u})^2$. In matrix form: $S_u^2 = \frac{1}{n} \boldsymbol{u}^T \boldsymbol{u} - \frac{1}{n^2} \boldsymbol{1}^T \boldsymbol{u}^T \boldsymbol{u} \boldsymbol{1}$. Because the genetic values are unknown, their genetic variance is unknown, too, and we need to look at its expectation: $E[S_u^2] = \frac{1}{n} \sigma_u^2 tr(K) - \frac{1}{n^2} \sigma_u^2 \boldsymbol{1}^T K \boldsymbol{1} = D_K \; \sigma_u^2$ where $D_K := (\bar{diag(K)} - \bar{K})$.

Let then fit a vc-LMM. If $D_K = 1$, the genetic variance in the reference population, $S_u^2$, will correspond to the variance component $\sigma_u^2$, but not otherwise. Under Hardy--Weinberg equilibrium, it can be shown that $D_K=1$ for genomic relationship matrices obtained with Van Raden's estimators. These estimators assume that the reference population is a population at HWE with allele frequencies equal to the allele frequencies observed in the sample, and that the locus are at linkage equilibrium. If the sample is at HWE, the diagonal of the GRM should be centered on 1 and the off-diagonal on 0.

Concretely, in order to compare $\sigma_{u,P}^2$ (from the pedigree) and $\sigma_{u,GRM_{VR1}}^2$ (Van Raden's 1st estimator), we need to refer them to the same reference population. Usually, the founders cannot be genotyped, the chose reference population hence is the one made of the genotyped individuals. Thus: $S_{u,GRM_{VR1}}^2 = \sigma_{u,GRM_{VR1}}^2$ and $S_{u,P}^2 = D_P \, \sigma_{u,P}^2$ with $D_P := 1 - \bar{F}_P$ where $\bar{F}_P = \bar{diag(A)} - 1$. The definition of $D_P$ shows the reduction of genetic variance in the current population compared to the the founders because of relatedness among non-founders.

#### SNPBLUP

Another vc-LMM model, called **SNPBLUP** can also be defined, that consists in decomposing the additive genomic values $\boldsymbol{u}_G$ into the matrix of SNP genotypes $M$ and the vector of SNP effects $\boldsymbol{\beta}$:

```{=tex}
\begin{align}
y = \boldsymbol{\text{1}}_n \mu + \boldsymbol{u}_S + \boldsymbol{\epsilon}_S
\end{align}
```
-   $\boldsymbol{u}_S := P M \boldsymbol{\beta} = \left[ \sum_{l=1}^L (M_{il} - M_{.l}) \beta_l \right]_{i \in \{1,\ldots,n\}}$

    -   $\boldsymbol{u}_S$: $n$-vector of genomic values modeled as random

    -   $P$: $n \times n$ column-wise, mean-centering matrix

    -   $M$: $n \times p$ matrix of SNP genotypes, *considered fixed*

-   $\forall l, \beta_l \sim \mathcal{N}(0, \sigma_\beta^2)$

    -   $\beta_l$: additive allelic effect of SNP $l$, *modeled as random*

    -   $\sigma_\beta^2$: variance of the allelic effects

-   $\boldsymbol{\epsilon}_S \sim \mathcal{N}(\boldsymbol{0}, \sigma_S^2 \, \text{Id})$.

#### Equivalence SNPBLUP-GBLUP

Following [Schreck et al (2019)](https://academic.oup.com/genetics/article/213/2/379/5930631), for GBLUP and SNPBLUP to be equivalent, $\boldsymbol{u}_S$ and $\boldsymbol{u}_G$ should be equal in distribution:

-   $M$ needs to be column-wise mean-centered (that is, left-multiplied by $P$), so that $\bar{\boldsymbol{u}}_G = 0$;

-   SNP genotypes need to be modeled as fixed and allelic effects as random, so that $Cov(\boldsymbol{u}_S) := Cov(P M \boldsymbol{\beta}) = \sigma_{\beta}^2 P M M^T P = \sigma_{\beta}^2 \times c_{VR1} \; GRM_{VR1}$ and thus $\sigma_{u,G}^2 := c \, \sigma_{\beta}^2$.

#### Genetic vs. genomic variance

TODO: explain what $\sigma_u^2$ is, as trace of cov(ui,uj)

#### LDAK approach

TODO

### Implementation

The R function below fits a variance-component linear mixed model (vc-LMM) as written in the reminders above.
Two packages can be used, [rrBLUP](https://cran.r-project.org/package=rrBLUP) and [sommer](https://cran.r-project.org/package=sommer), both implementing algorithms for ReML.

-   When choosing sommer, if no kinship is given (missing argument K), a SNPBLUP model will be fitted, otherwise a GBLUP model will be fitted; more details below.

-   When choosing sommer, a GBLUP model is fitted and the best predictor of the genetic variance from Schreck et al (2019) is returned; more details below.

```{r implem_vcLMM}
vcLMM <- function(data, inds, K, Z, colY="pheno1", colZ="ind_id", pkg="rrBLUP"){
  ## check the inputs
  stopifnot(is.data.frame(data),
            is.character(inds),
            xor(missing(K), missing(Z)),
            all(c(colY, colZ) %in% colnames(data)),
            all(inds %in% as.character(data[,colZ])))
  model <- "GBLUP"
  if(missing(K)){
    model <- "SNPBLUP"
    stopifnot(all(inds %in% rownames(Z)))
  } else{
    stopifnot(all(inds %in% rownames(K)),
              all(inds %in% colnames(K)))
  }

  ## subset the data
  idx <- which(as.character(data[,colZ]) %in% inds)
  subData <- droplevels(data[idx,])

  ## fit the model
  if(pkg == "rrBLUP"){
    ## prepare the inputs
    if(model == "GBLUP"){
      print(paste0("fit a vc-LMM (K=", deparse(substitute(K)),
                   ") with R/rrBLUP"))
      subData[,colZ] <- factor(as.character(subData[,colZ]))
      Z <- model.matrix(as.formula(paste0("~ 0 + ", colZ)), data=subData)
      colnames(Z) <- gsub(paste0("^", colZ), "", colnames(Z))
      y <- matrix(subData[, colY], ncol=1)
      K <- K[colnames(Z), colnames(Z)]
      X <- matrix(1, nrow=nrow(subData))
      st <- system.time(
          fit <- mixed.solve(y=y, X=X, Z=Z, K=K, method="REML"))
      subData$BLUP_u <- setNames(c(fit$u), colnames(Z))[subData[,colZ]]
    } else if(model == "SNPBLUP"){
      print("fit a SNPBLUP model with R/rrBLUP")
      Z <- Z[as.character(subData[,colZ]),]
      y <- matrix(subData[, colY], ncol=1)
      X <- matrix(1, nrow=nrow(subData))
      st <- system.time(
          fit <- mixed.solve(y=y, X=X, Z=Z, K=NULL, method="REML"))
      attr(subData, "BLUP_u") <- setNames(c(fit$u), colnames(Z))
      subData$Z_BLUP_u <- (Z %*% fit$u)[,1]
    }
    print(st)
    attr(subData, "Vu") <- fit$Vu
    attr(subData, "Ve") <- fit$Ve
    attr(subData, "BLUE_beta") <- c(fit$beta)

  } else if(pkg == "sommer"){
    print("fit a GBLUP model with R/sommer + Schreck's best predictor")
    y <- as.vector(subData[, colY])
    names(y) <- as.character(subData[, colZ])
    n <- length(y)
    ## See the code of Schreck et al (2019) in their supplements
    y_scaled <- y / sd(y)
    ## subData_mmer <- data.frame(id=factor(as.character(1:n), as.character(1:n)),
    subData_mmer <- data.frame(id=factor(names(y_scaled)),
                               y_scaled=y_scaled)
    ones <- matrix(1, nrow=n, ncol=1)
    P <- diag(1, n, n) - matrix(1, n, n) / n
    X <- Z[as.character(subData_mmer$id),] # marker genotypes
    p <- dim(X)[2]
    c <- sum(colMeans(X) * (1 - colMeans(X) / 2))
    GRM <- P %*% tcrossprod(X) %*% P / c # eq.3
    rownames(GRM) <- colnames(GRM) <- rownames(X)
    GRM <- as.matrix(Matrix::nearPD(GRM)$mat) # avoid non-positive-definite matrix
    st <- system.time(
      fit <- mmer(fixed = y_scaled ~ 1,
                  random = ~ vsr(id, Gu=GRM),
                  rcov = ~ units,
                  data = subData_mmer,
                  nIters=50, tolParConvLL=1e-7, tolParInv=1e-9, dateWarning=FALSE))
    print(st)
    var.g.hat <- fit$sigma[["u:id"]][1]
    var.e.hat <- fit$sigma[["units"]][1]
    mu.hat <- rep(fit$Beta[1,"Estimate"], n)
    g.hat <- fit$U[["u:id"]]$y_scaled
    cov.g.hat <- fit$VarU[["u:id"]]$y_scaled
    attr(subData, "var_g") <- var.g.hat
    attr(subData, "var_e") <- var.e.hat
    attr(subData, "mu") <- mu.hat
    GenVarCur <- function(GRM, varg, eBLUP, eBLUPcov){
      n <- dim(GRM)[[1]]
      V <- varg * sum(diag(GRM)) / (n - 1) # eq.16
      W <- V + sum(eBLUP^2) / (n - 1) - sum(diag(eBLUPcov)) / (n - 1) # right column of p.393
      return(c(V, W))
    }
    gv_cur <- GenVarCur(GRM=GRM, varg=var.g.hat, eBLUP=g.hat, eBLUPcov=cov.g.hat)
    V.hat <- gv_cur[1]
    h2.V <- V.hat
    sum.V <- V.hat + var.e.hat
    h2.V.sum <- V.hat / sum.V
    W.hat <- gv_cur[2]
    h2.W <- W.hat
    sum.W <- W.hat + var.e.hat
    h2.W.sum <- W.hat / sum.W
    attr(subData, "out_V") <- c("V"=V.hat, "h2"=h2.V, "sum"=sum.V, "h2.sum"=h2.V.sum)
    attr(subData, "out_W") <- c("W"=W.hat, "h2"=h2.W, "sum"=sum.W, "h2.sum"=h2.W.sum)
  }
  
  return(subData)
}
```

### With the true identities by descent

The following vc-LMM is adjusted:

```{=tex}
\begin{align}
y = \boldsymbol{\text{1}}_n \mu + \boldsymbol{u}_I + \boldsymbol{\epsilon}_I
\end{align}
```
-   $\boldsymbol{u}_I \sim \mathcal{N}(\boldsymbol{0}, \sigma_{u,I}^2 \, GRM_{IBD})$

    -   $GRM_{IBD}$: $n \times n$ matrix of additive genetic relationships from the true identities by descent

    -   $\boldsymbol{u}_I$: $n$-vector of genetic values modeled as random

    -   $\sigma_{u,I}^2$: genetic variance component

-   $\boldsymbol{\epsilon}_I \sim \mathcal{N}(\boldsymbol{0}, \sigma_I^2 \, \text{Id})$.

#### Trait 1

##### All generations

```{r, fig.width=10}
fitI1 <- vcLMM(data=pedDat, inds=as.character(pedDat$ind_id),
               K=GRM_IBD, colY="pheno1", colZ="ind_id", pkg="rrBLUP")

c("Vu_hat"=attr(fitI1, "Vu"),
  "Ve_hat"=attr(fitI1, "Ve"),
  "h2_hat"=attr(fitI1, "Vu") / (attr(fitI1, "Vu") + attr(fitI1, "Ve")))
c("true_Vu"=truth$trait1$varBV_all)
attr(fitI1, "Vu") - truth$trait1$varBV_all
100 * (attr(fitI1, "Vu") - truth$trait1$varBV_all) / truth$trait1$varBV_all

cor(fitI1$BLUP_u, fitI1$bv1)

fitI1$generation <- factor(as.character(fitI1$generation),
                           levels=as.character(sort(unique(fitI1$generation))),
                           ordered=TRUE)
(mu_hat <- attr(fitI1, "BLUE_beta"))
ggplot(fitI1) +
  aes(x=BLUP_u, y=bv1 - mu_hat, color=generation) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_point() +
  labs(title="Trait 1; GBLUP with GRM_IBD; all generations",
       subtitle=simulDir,
       color="Generation") +
  theme_bw()

(D_IBD <- mean(diag(GRM_IBD)) - mean(c(GRM_IBD)))
```

#### Trait 2

Left as an exercise.

### With the pedigree

The following vc-LMM, sometimes called the **PBLUP** model, is adjusted:

```{=tex}
\begin{align}
y = \boldsymbol{\text{1}}_n \mu + \boldsymbol{u}_P + \boldsymbol{\epsilon}_P
\end{align}
```
-   $\boldsymbol{u}_P \sim \mathcal{N}(\boldsymbol{0}, \sigma_{u,P}^2 A)$

    -   $A$: $n \times n$ matrix of additive genetic relationships from the pedigree

    -   $\boldsymbol{u}_P$: $n$-vector of genetic values modeled as random

    -   $\sigma_{u,P}^2$: genetic variance component

-   $\boldsymbol{\epsilon}_P \sim \mathcal{N}(\boldsymbol{0}, \sigma_P^2 \text{Id})$.

#### Trait 1

##### All generations

```{r, fig.width=10}
fitA1 <- vcLMM(data=pedDat, inds=as.character(pedDat$ind_id),
               K=A, colY="pheno1", colZ="ind_id", pkg="rrBLUP")

c("Vu_hat"=attr(fitA1, "Vu"),
  "Ve_hat"=attr(fitA1, "Ve"),
  "h2_hat"=attr(fitA1, "Vu") / (attr(fitA1, "Vu") + attr(fitA1, "Ve")))
c("true_Vu"=truth$trait1$varBV_all)
attr(fitA1, "Vu") - truth$trait1$varBV_all
100 * (attr(fitA1, "Vu") - truth$trait1$varBV_all) / truth$trait1$varBV_all

cor(fitA1$BLUP_u, fitA1$bv1)

fitA1$generation <- factor(as.character(fitA1$generation),
                           levels=as.character(sort(unique(fitA1$generation))),
                           ordered=TRUE)
(mu_hat <- attr(fitA1, "BLUE_beta"))
ggplot(fitA1) +
  aes(x=BLUP_u, y=bv1 - mu_hat, color=generation) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_point() +
  labs(title="Trait 1; ABLUP with pedigree; all generations",
       subtitle=simulDir,
       color="Generation") +
  theme_bw()

(D_A <- mean(diag(A)) - mean(c(A)))
```

#### Trait 2

Left as an exercise.

### With markers, assuming LE

#### Trait 1 with GBLUP

##### All generations

```{r, fig.width=10}
fitG1 <- vcLMM(data=pedDat, inds=as.character(pedDat$ind_id),
               colY="pheno1", colZ="ind_id",
               K=GRM_VR1, #as.matrix(Matrix::nearPD(GRM_VR1)$mat),
               pkg="rrBLUP")

c("Vu_hat"=attr(fitG1, "Vu"),
  "Ve_hat"=attr(fitG1, "Ve"),
  "h2_hat"=attr(fitG1, "Vu") / (attr(fitG1, "Vu") + attr(fitG1, "Ve")))
c("true_Vu"=truth$trait1$varBV_all)
attr(fitG1, "Vu") - truth$trait1$varBV_all
100 * (attr(fitG1, "Vu") - truth$trait1$varBV_all) / truth$trait1$varBV_all

cor(fitG1$BLUP_u, fitG1$bv1)

fitG1$generation <- factor(as.character(fitG1$generation),
                           levels=as.character(sort(unique(fitG1$generation))),
                           ordered=TRUE)
(mu_hat <- attr(fitG1, "BLUE_beta"))
ggplot(fitG1) +
  aes(x=BLUP_u, y=bv1 - mu_hat, color=generation) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_point() +
  labs(title="Trait 1; GBLUP with GRM_VR1; all generations",
       subtitle=simulDir,
       color="Generation") +
  theme_bw()

## Compare estimates of genetic variances using the genetic variance components
## obtained with the pedigree relationships vs with Van Raden's 1st estimator:
(D_VR1 <- mean(diag(GRM_VR1)) - mean(c(GRM_VR1)))
D_VR1 * attr(fitG1, "Vu")
D_A * attr(fitA1, "Vu")
```

#### Trait 1 with SNPBLUP

##### All generations

```{r, fig.width=10}
fitS1 <- vcLMM(data=pedDat, inds=as.character(pedDat$ind_id),
               colY="pheno1", colZ="ind_id",
               Z=Z_VR1, pkg="rrBLUP")

c("Vu_hat"=attr(fitS1, "Vu"),
  "Ve_hat"=attr(fitS1, "Ve"))
c("true_Vbeta"=truth$trait1$varBeta)
attr(fitS1, "Vu") - truth$trait1$varBeta
100 * (attr(fitS1, "Vu") - truth$trait1$varBeta) / truth$trait1$varBeta

cor(snpInfos$beta_trait_1, attr(fitS1, "BLUP_u")[snpInfos$snp_id])
plot(snpInfos$beta_trait_1, attr(fitS1, "BLUP_u"), asp=1)
abline(a=0, b=1, lty=2)

cor(fitS1$Z_BLUP_u, fitS1$bv1)

fitS1$generation <- factor(as.character(fitS1$generation),
                           levels=as.character(sort(unique(fitS1$generation))),
                           ordered=TRUE)
(mu_hat <- attr(fitS1, "BLUE_beta"))
ggplot(fitS1) +
  aes(x=Z_BLUP_u, y=bv1 - mu_hat, color=generation) +
  geom_abline(slope=1, intercept=0, linetype="dotted") +
  geom_point() +
  labs(title="Trait 1; SNPBLUP with Z_VR1; all generations",
       subtitle=simulDir,
       color="Generation") +
  theme_bw()

## Compare the genetic variances between GBLUP (with Van Raden's 1st estimator)
## and SNPBLUP:
(c_VR1 <- (2 * sum(AFs_VR1 * (1 - AFs_VR1))))
c_VR1 * attr(fitS1, "Vu")
attr(fitG1, "Vu")
```

#### Trait 2 with GBLUP

Left as an exercise.

#### Trait 2 with SNPBLUP

Left as an exercise.

### With markers, handling LD

#### Trait 1 with GBLUP and GRM_LDAK

##### All generations

```{r}
fitL1 <- vcLMM(data=pedDat, inds=as.character(pedDat$ind_id),
               colY="pheno1", colZ="ind_id",
               K=GRM_ldak, #as.matrix(Matrix::nearPD(GRM_LDAK)$mat),
               pkg="rrBLUP")

c("Vu_hat"=attr(fitL1, "Vu"),
  "Ve_hat"=attr(fitL1, "Ve"),
  "h2_hat"=attr(fitL1, "Vu") / (attr(fitG1, "Vu") + attr(fitG1, "Ve")))
c("true_Vu"=truth$trait1$varBV_all)
attr(fitL1, "Vu") - truth$trait1$varBV_all
100 * (attr(fitL1, "Vu") - truth$trait1$varBV_all) / truth$trait1$varBV_all

cor(fitL1$BLUP_u, fitL1$bv1)

(D_LDAK <- mean(diag(GRM_ldak)) - mean(c(GRM_ldak)))
```

#### Trait 2

Left as an exercise.

#### Trait 1 with Schreck's et al best predictor

##### All generations

```{r}
fitBP1 <- vcLMM(data=pedDat, inds=as.character(pedDat$ind_id),
                Z=genos, colY="pheno1", colZ="ind_id", pkg="sommer")
attr(fitBP1, "var_g")
attr(fitBP1, "var_e")
attr(fitBP1, "out_V")
attr(fitBP1, "out_W")
```

#### Trait 2

Left as an exercise.

## Predict the breeding values of non-phenotyped individuals

Let us consider that the available phenotypic data are those of generations 0 to 9, and that only the genotyping data are available for generation 10. A vc-LMM can be trained on the first dataset (generations 0 to 9), and used to predict the breeding values of individuals from generation 10.

```{r}
length(inds_trn <- inds_notlast)
length(inds_tst <- inds_last)
```


### Using the estimated SNP effects

#### Trait 1

```{r}
dim(genos_trn <- genos[inds_trn,])
AFs_trn <- colMeans(genos_trn) / 2
tmp <- matrix(rep(1, nrow(genos_trn))) %*% (2 * AFs_trn)
Z_trn <- genos_trn - tmp
fit_trn <- vcLMM(data=pedDat, inds=as.character(inds_trn),
                 colY="pheno1", colZ="ind_id",
                 Z=Z_trn, pkg="rrBLUP")

dim(genos_tst <- genos[as.character(inds_tst),])
pred_BV1_SNPs <- (genos_tst %*% attr(fit_trn, "BLUP_u"))[,1]
cor(pred_BV1_SNPs, setNames(pedDat$bv1, pedDat$ind_id)[names(pred_BV1_SNPs)])
plot(pred_BV1_SNPs, setNames(pedDat$bv1, pedDat$ind_id)[names(pred_BV1_SNPs)],
     main="Prediction accuracy with SNP effects",
     xlab="predicted BV1 (last generation)",
     ylab="true BV1 (last generation)")
```

#### Trait 2

Left as an exercise.

### Using the genetic relationships

#### Trait 1

```{r}
length(y_trn <- setNames(pedDat$pheno1, pedDat$ind_id)[inds_trn])

## With GRM_IBD
## TODO

## With A
dim(G_trn_tst <- A[inds_trn, inds_tst])
dim(G_trn <- A[inds_trn, inds_trn])
lambda_hat <- attr(fitA1, "Ve") / attr(fitA1, "Vu")
length(pred_BV1_A <- (t(G_trn_tst) %*% solve(G_trn + lambda_hat * diag(length(inds_trn))) %*% y_trn)[,1])
cor(pred_BV1_A, setNames(pedDat$bv1, pedDat$ind_id)[names(pred_BV1_A)])
plot(pred_BV1_A, setNames(pedDat$bv1, pedDat$ind_id)[names(pred_BV1_A)],
     main="Prediction accuracy with A",
     xlab="predicted BV1 (last generation)",
     ylab="true BV1 (last generation)")

## With GRM_VR1
dim(G_trn_tst <- GRM_VR1[inds_trn, inds_tst])
dim(G_trn <- GRM_VR1[inds_trn, inds_trn])
lambda_hat <- attr(fitG1, "Ve") / attr(fitG1, "Vu")
length(pred_BV1_VR1 <- (t(G_trn_tst) %*% solve(G_trn + lambda_hat * diag(length(inds_trn))) %*% y_trn)[,1])
cor(pred_BV1_VR1, setNames(pedDat$bv1, pedDat$ind_id)[names(pred_BV1_VR1)])
plot(pred_BV1_VR1, setNames(pedDat$bv1, pedDat$ind_id)[names(pred_BV1_VR1)],
     main="Prediction accuracy with GRM_VR1",
     xlab="predicted BV1 (last generation)",
     ylab="true BV1 (last generation)")

## With GRM_LDAK
## TODO
```

#### Trait 2

Left as an exercise.


<!-- ==================================================================== -->

# Multivariate statistical analysis for both traits jointly

Quite slow.

```{r, eval=FALSE}
if(FALSE){
  inds <- as.character(pedDat$ind_id)
  colZ <- "ind_id"
  idx <- which(as.character(pedDat[,colZ]) %in% inds)
  subData <- droplevels(pedDat[idx,])
  subData$id <- factor(as.character(subData[,colZ]))
  
  fitA12 <- mmer(fixed = cbind(pheno1, pheno2) ~ 1,
                 random = ~ vsr(id, Gu=A, Gtc=unsm(2)),
                 rcov = ~ vsr(units, Gtc=unsm(2)),
                 data=subData, nIters=10, verbose=FALSE)
}
```

# Appendix

```{r}
print(sessionInfo(), locale=FALSE)
```
